import { describe, expect, it } from "vitest";
import {
	createDeclaration,
	Declaration,
	parseSql,
	StringCompilationUnit,
	ZodGenerator,
} from "../src";

describe("ZodGenerator", () => {
	it("Formats output file name", () => {
		const generator = new ZodGenerator("test.sql");
		const outputFileName = generator.getOutputFileName();
		expect(outputFileName).toBe("test.schemas.ts");
	});
	describe("Generates simple zod types", () => {
		const types: Record<string, string> = {
			"character varying": "z.string()",
			text: "z.string()",
			integer: "z.integer()",
			"double precision": "z.number()",
			boolean: "z.boolean()",
			json: "z.json()",
			jsonb: "z.json()",
			"timestamp with time zone":
				"z.union([z.string(), z.date()]).pipe(z.transform((val) => val instanceof Date ? val : new Date(val)))",
		};
		for (const ty in types) {
			it(ty, () => {
				const generator = new ZodGenerator("test.sql");
				const result = generator.generateType(
					"ITest",
					{
						value: {
							name: "value",
							dataType: ty,
							isNullable: false,
						},
					},
					false,
				);
				expect(result).toBe(
					`export const testSchema = z.object({\n` +
						`  value: ${types[ty]},\n` +
						`});\n` +
						`\n` +
						`export type ITest = z.infer<typeof testSchema>;`,
				);
			});
		}
	});
	it("Generates nullable zod types", () => {
		const generator = new ZodGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				value: {
					name: "value",
					dataType: "text",
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toContain("z.object({\n  value: z.string().optional(),\n})");
	});
	it("Generates optional zod types", () => {
		const generator = new ZodGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				value: {
					name: "value",
					dataType: "text",
					isNullable: true,
				},
			},
			true,
		);
		expect(result).toContain("z.object({\n  value: z.string().optional(),\n})");
	});
	it("Generates array zod types", () => {
		const generator = new ZodGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				a: {
					name: "a",
					dataType: "text[]",
					isNullable: false,
				},
				b: {
					name: "b",
					dataType: "integer[]",
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toContain(
			"z.object({\n" +
				"  a: z.string().array(),\n" +
				"  b: z.integer().array().optional(),\n" +
				"})",
		);
	});
	it("Generates nested zod types", () => {
		const generator = new ZodGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				outer: {
					name: "outer",
					dataType: {
						inner: {
							name: "inner",
							dataType: "text",
							isNullable: false,
						},
					},
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toContain(
			"z.object({\n" +
				"  outer: z.object({\n" +
				"    inner: z.string(),\n" +
				"  }).optional(),\n" +
				"})",
		);
	});
	it("Other types are `unknown`", () => {
		const generator = new ZodGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				a: {
					name: "a",
					dataType: "someothertype",
					isNullable: false,
				},
			},
			false,
		);
		expect(result).toContain("z.object({\n  a: z.unknown(),\n})");
	});
	it("Generates full module", async () => {
		const database = { tables: {}, routines: {} };
		const queries = await parseSql(
			new StringCompilationUnit(`
			-- @repo Test
			-- @query testQuery1
			SELECT 1 AS value;
			-- @query testQuery2
			SELECT :id::TEXT AS value, :name_ AS value2;
			-- @query testQuery3
			SELECT 3 AS value LIMIT 1;
			-- @query testQuery4
			UPDATE "users" SET name = :name::TEXT
		`),
		);
		const decls = queries
			.map((query) => createDeclaration(database, query))
			.filter(Boolean) as Declaration[];
		const generator = new ZodGenerator("test.sql");
		for (const decl of decls) {
			generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		}
		expect(generator.toString()).toContain(
			`/* Generated by tradukisto - do not edit manually */

import z from "zod/v4";

export const testQuery1Schema = z.object({
  value: z.integer(),
});

export type ITestQuery1 = z.infer<typeof testQuery1Schema>;

export const testQuery2Schema = z.object({
  value: z.string(),
  value2: z.unknown().optional(),
});

export type ITestQuery2 = z.infer<typeof testQuery2Schema>;

export const testQuery2ParamsSchema = z.object({
  id: z.string(),
  name: z.unknown().optional(),
});

export type ITestQuery2Params = z.infer<typeof testQuery2ParamsSchema>;

export const testQuery3Schema = z.object({
  value: z.integer(),
});

export type ITestQuery3 = z.infer<typeof testQuery3Schema>;

export const testQuery4ParamsSchema = z.object({
  name: z.string(),
});

export type ITestQuery4Params = z.infer<typeof testQuery4ParamsSchema>;`,
		);
	});
});
