import type { AST } from "node-sql-parser";
import { describe, expect, it } from "vitest";
import {
	createDeclaration,
	Declaration,
	ParamMap,
	ParsedQuery,
	parseSql,
	ResolvedType,
	StringCompilationUnit,
	TsGenerator,
} from "../src";

class MockDeclaration implements Declaration {
	public parsedQuery: ParsedQuery = {
		queryName: "testQuery",
		typeName: "TestQuery",
		query: "SELECT 1",
		paramMap: new ParamMap(),
		ast: {} as AST,
	};
	public resultType: ResolvedType = {};
	public parameterTypes: ResolvedType = {};

	getParsedQuery() {
		return this.parsedQuery;
	}

	resolveResultType() {
		return this.resultType;
	}

	resolveParameterTypes() {
		return this.parameterTypes;
	}

	isSingleRow() {
		return false;
	}
}

describe("TsGenerator", () => {
	describe("Generates simple Typescript types", () => {
		const types: Record<string, string> = {
			"character varying": "string",
			text: "string",
			integer: "number",
			"double precision": "number",
			boolean: "boolean",
			jsonb: "any", // TODO
			"timestamp with time zone": "Date",
		};
		for (const ty in types) {
			it(ty, () => {
				const generator = new TsGenerator();
				const result = generator.generateType(
					"Test",
					{
						value: {
							name: "value",
							dataType: ty,
							isNullable: false,
						},
					},
					false,
				);
				expect(result).toBe(
					`export interface Test {\n  value: ${types[ty]},\n}`,
				);
			});
		}
	});
	it("Generates nullable Typescript types (non-optional)", () => {
		const generator = new TsGenerator();
		const result = generator.generateType(
			"Test",
			{
				value: {
					name: "value",
					dataType: "text",
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toBe("export interface Test {\n  value: string | null,\n}");
	});
	it("Generates nullable Typescript types (optional)", () => {
		const generator = new TsGenerator();
		const result = generator.generateType(
			"Test",
			{
				value: {
					name: "value",
					dataType: "text",
					isNullable: true,
				},
			},
			true,
		);
		expect(result).toBe("export interface Test {\n  value?: string | null,\n}");
	});
	it("Generates array Typescript types", () => {
		const generator = new TsGenerator();
		const result = generator.generateType(
			"Test",
			{
				a: {
					name: "a",
					dataType: "text[]",
					isNullable: false,
				},
				b: {
					name: "b",
					dataType: "integer[]",
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toBe(
			"export interface Test {\n  a: string[],\n  b: number[] | null,\n}",
		);
	});
	it("Generates nested typesript types", () => {
		const generator = new TsGenerator();
		const result = generator.generateType(
			"Test",
			{
				outer: {
					name: "outer",
					dataType: {
						inner: {
							name: "inner",
							dataType: "text",
							isNullable: false,
						},
					},
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toBe(
			"export interface Test {\n  outer: {\n    inner: string,\n  } | null,\n}",
		);
	});
	it("Other types are `unkown`", () => {
		const generator = new TsGenerator();
		const result = generator.generateType(
			"Test",
			{
				a: {
					name: "a",
					dataType: "someothertype",
					isNullable: false,
				},
			},
			false,
		);
		expect(result).toBe("export interface Test {\n  a: unknown,\n}");
	});
	it("Doesn't allow duplicate declaration names", () => {
		const decl = new MockDeclaration();
		const generator = new TsGenerator();
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(() => {
			generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		}).toThrow();
	});
	it("Outputs file header comment", () => {
		const decl = new MockDeclaration();
		const generator = new TsGenerator();
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(generator.toString()).toContain(
			"/* Generated by tradukisto - do not edit manually */\n\nexport",
		);
	});
	it("Outputs SQL string", () => {
		const decl = new MockDeclaration();
		const generator = new TsGenerator();
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(generator.toString()).toContain(
			"export const testQuerySql = `-- testQuery\nSELECT 1`;",
		);
	});
	it("Generates repo with various methods", async () => {
		const database = { tables: {}, routines: {} };
		const queries = await parseSql(
			new StringCompilationUnit(`
			-- @repo Test
			-- @query testQuery1
			SELECT 1 AS value;
			-- @query testQuery2
			SELECT :id::TEXT AS value, :name AS value2;
			-- @query testQuery3
			SELECT 3 AS value LIMIT 1;
		`),
		);
		const decls = queries
			.map((query) => createDeclaration(database, query))
			.filter(Boolean) as Declaration[];
		const generator = new TsGenerator();
		for (const decl of decls) {
			generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		}
		expect(generator.toString("Test")).toContain(`
export class TestRepo {
  protected client: PostgresClient;

  constructor(client: PostgresClient) {
    this.client = client;
  }

  async testQuery1(): Promise<ITestQuery1[]> {
    const res = await this.client.fetchRows(testQuery1Sql);
    return res;
  }

  async testQuery2(params: ITestQuery2Params): Promise<ITestQuery2[]> {
    const res = await this.client.fetchRows(testQuery2Sql, [
      params.id === undefined ? null : params.id,
      params.name === undefined ? null : params.name,
    ]);
    return res;
  }

  async testQuery3(): Promise<ITestQuery3 | null> {
    const res = await this.client.fetchRows(testQuery3Sql);
    return res?.[0] ?? null;
  }
}`);
	});
});
