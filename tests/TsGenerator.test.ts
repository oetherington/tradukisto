import type { AST } from "node-sql-parser";
import { describe, expect, it } from "vitest";
import {
	createDeclaration,
	Declaration,
	ParamMap,
	ParsedQuery,
	parseSql,
	ResolvedType,
	StringCompilationUnit,
	TsGenerator,
	ZodGenerator,
} from "../src";

class MockDeclaration implements Declaration {
	public parsedQuery: ParsedQuery = {
		queryName: "testQuery",
		typeName: "TestQuery",
		query: "SELECT 1",
		paramMap: new ParamMap(),
		ast: {} as AST,
	};
	public resultType: ResolvedType = {};
	public parameterTypes: ResolvedType = {};

	getParsedQuery() {
		return this.parsedQuery;
	}

	resolveResultType() {
		return this.resultType;
	}

	resolveParameterTypes() {
		return this.parameterTypes;
	}

	getResultType() {
		return "many" as const;
	}
}

describe("TsGenerator", () => {
	it("Formats output file path", () => {
		const generator = new TsGenerator("test.sql");
		const outputFileName = generator.getOutputFilePath();
		expect(outputFileName).toBe("test.repo.ts");
	});
	describe("Generates simple Typescript types", () => {
		const types: Record<string, string> = {
			"character varying": "string",
			text: "string",
			integer: "number",
			"double precision": "number",
			boolean: "boolean",
			json: "Json",
			jsonb: "Json",
			"timestamp with time zone": "Date",
		};
		for (const ty in types) {
			it(ty, () => {
				const generator = new TsGenerator("test.sql");
				const result = generator.generateType(
					"ITest",
					{
						value: {
							name: "value",
							dataType: ty,
							isNullable: false,
						},
					},
					false,
				);
				expect(result).toBe(
					`export interface ITest {\n  value: ${types[ty]},\n}`,
				);
			});
		}
	});
	it("Generates nullable Typescript types (non-optional)", () => {
		const generator = new TsGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				value: {
					name: "value",
					dataType: "text",
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toBe("export interface Test {\n  value: string | null,\n}");
	});
	it("Generates nullable Typescript types (optional)", () => {
		const generator = new TsGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				value: {
					name: "value",
					dataType: "text",
					isNullable: true,
				},
			},
			true,
		);
		expect(result).toBe("export interface Test {\n  value?: string | null,\n}");
	});
	it("Generates array Typescript types", () => {
		const generator = new TsGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				a: {
					name: "a",
					dataType: "text[]",
					isNullable: false,
				},
				b: {
					name: "b",
					dataType: "integer[]",
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toBe(
			"export interface Test {\n  a: string[],\n  b: number[] | null,\n}",
		);
	});
	it("Generates nested typescript types", () => {
		const generator = new TsGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				outer: {
					name: "outer",
					dataType: {
						inner: {
							name: "inner",
							dataType: "text",
							isNullable: false,
						},
					},
					isNullable: true,
				},
			},
			false,
		);
		expect(result).toBe(
			"export interface Test {\n  outer: {\n    inner: string,\n  } | null,\n}",
		);
	});
	it("Other types are `unknown`", () => {
		const generator = new TsGenerator("test.sql");
		const result = generator.generateType(
			"Test",
			{
				a: {
					name: "a",
					dataType: "someothertype",
					isNullable: false,
				},
			},
			false,
		);
		expect(result).toBe("export interface Test {\n  a: unknown,\n}");
	});
	it("Doesn't allow duplicate declaration names", () => {
		const decl = new MockDeclaration();
		const generator = new TsGenerator("test.sql");
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(() => {
			generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		}).toThrow();
	});
	it("Outputs file header comment", () => {
		const decl = new MockDeclaration();
		const generator = new TsGenerator("test.sql");
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(generator.toString()).toContain(
			"/* Generated by tradukisto - do not edit manually */\n\nexport",
		);
	});
	it("Outputs SQL string", () => {
		const decl = new MockDeclaration();
		const generator = new TsGenerator("test.sql");
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(generator.toString()).toContain(
			"export const testQuerySql = `-- testQuery\nSELECT 1`;",
		);
	});
	it("Imports `Json` when needed", () => {
		const decl = new MockDeclaration();
		decl.resultType = {
			value: {
				name: "value",
				dataType: "json",
				isNullable: false,
			},
		};
		const generator = new TsGenerator("test.sql");
		generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		expect(generator.toString()).toContain(
			`import type { Json } from "tradukisto";`,
		);
	});
	it("Generates repo with various methods", async () => {
		const database = { tables: {}, routines: {} };
		const queries = await parseSql(
			new StringCompilationUnit(`
			-- @repo Test
			-- @query testQuery1
			SELECT 1 AS value;
			-- @query testQuery2
			SELECT :id::TEXT AS value, :name_ AS value2;
			-- @query testQuery3
			SELECT 3 AS value LIMIT 1;
			-- @query testQuery4
			UPDATE "users" SET name = :name::TEXT
		`),
		);
		const decls = queries
			.map((query) => createDeclaration(database, query))
			.filter(Boolean) as Declaration[];
		const generator = new TsGenerator("test.sql");
		for (const decl of decls) {
			generator.addDeclaration(decl.getParsedQuery().queryName, decl);
		}
		expect(generator.toString()).toBe(
			`/* Generated by tradukisto - do not edit manually */

import type { PostgresClient } from "tradukisto";

export interface ITestQuery1 {
  value: number,
}

export const testQuery1Sql = \`-- Test.testQuery1
SELECT 1 AS value;\`;

export interface ITestQuery2 {
  value: string,
  value2: unknown | null,
}

export interface ITestQuery2Params {
  id: string,
  name?: unknown | null,
}

export const testQuery2Sql = \`-- Test.testQuery2
SELECT $1::TEXT AS "value", $2 AS "value2"\`;

export interface ITestQuery3 {
  value: number,
}

export const testQuery3Sql = \`-- Test.testQuery3
SELECT 3 AS value LIMIT 1;\`;

export interface ITestQuery4Params {
  name: string,
}

export const testQuery4Sql = \`-- Test.testQuery4
UPDATE "users" SET name = $1::TEXT\`;

export class TestRepo {
  protected client: PostgresClient;

  constructor(client: PostgresClient) {
    this.client = client;
  }

  async testQuery1(): Promise<ITestQuery1[]> {
    const res: ITestQuery1[] = await this.client.fetchRows(testQuery1Sql);
    return res;
  }

  async testQuery2(params: ITestQuery2Params): Promise<ITestQuery2[]> {
    const res: ITestQuery2[] = await this.client.fetchRows(testQuery2Sql, [
      params.id === undefined ? null : params.id,
      params.name === undefined ? null : params.name,
    ]);
    return res;
  }

  async testQuery3(): Promise<ITestQuery3 | null> {
    const res: ITestQuery3[] = await this.client.fetchRows(testQuery3Sql);
    return res?.[0] ?? null;
  }

  async testQuery4(params: ITestQuery4Params): Promise<void> {
    await this.client.fetchRows(testQuery4Sql, [
      params.name === undefined ? null : params.name,
    ]);
  }
}`,
		);
	});
	it("Generates repo with various methods, with imported types", async () => {
		const database = { tables: {}, routines: {} };
		const queries = await parseSql(
			new StringCompilationUnit(`
			-- @repo Test
			-- @query testQuery1
			SELECT 1 AS value;
			-- @query testQuery2
			SELECT :id::TEXT AS value, :name_ AS value2;
			-- @query testQuery3
			SELECT 3 AS value LIMIT 1;
			-- @query testQuery4
			UPDATE "users" SET name = :name::TEXT
		`),
		);
		const decls = queries
			.map((query) => createDeclaration(database, query))
			.filter(Boolean) as Declaration[];
		const zodGenerator = new ZodGenerator("test.sql");
		const tsGenerator = new TsGenerator("test.sql");
		tsGenerator.setImportTypesGenerator(zodGenerator);
		for (const decl of decls) {
			const { queryName } = decl.getParsedQuery();
			zodGenerator.addDeclaration(queryName, decl);
			tsGenerator.addDeclaration(queryName, decl);
		}
		expect(tsGenerator.toString()).toBe(
			`/* Generated by tradukisto - do not edit manually */

import type { PostgresClient } from "tradukisto";
import type {
  ITestQuery1,
  ITestQuery2,
  ITestQuery2Params,
  ITestQuery3,
  ITestQuery4Params,
} from "./test.schemas.ts";

export const testQuery1Sql = \`-- Test.testQuery1
SELECT 1 AS value;\`;

export const testQuery2Sql = \`-- Test.testQuery2
SELECT $1::TEXT AS "value", $2 AS "value2"\`;

export const testQuery3Sql = \`-- Test.testQuery3
SELECT 3 AS value LIMIT 1;\`;

export const testQuery4Sql = \`-- Test.testQuery4
UPDATE "users" SET name = $1::TEXT\`;

export class TestRepo {
  protected client: PostgresClient;

  constructor(client: PostgresClient) {
    this.client = client;
  }

  async testQuery1(): Promise<ITestQuery1[]> {
    const res: ITestQuery1[] = await this.client.fetchRows(testQuery1Sql);
    return res;
  }

  async testQuery2(params: ITestQuery2Params): Promise<ITestQuery2[]> {
    const res: ITestQuery2[] = await this.client.fetchRows(testQuery2Sql, [
      params.id === undefined ? null : params.id,
      params.name === undefined ? null : params.name,
    ]);
    return res;
  }

  async testQuery3(): Promise<ITestQuery3 | null> {
    const res: ITestQuery3[] = await this.client.fetchRows(testQuery3Sql);
    return res?.[0] ?? null;
  }

  async testQuery4(params: ITestQuery4Params): Promise<void> {
    await this.client.fetchRows(testQuery4Sql, [
      params.name === undefined ? null : params.name,
    ]);
  }
}`,
		);
	});
});
