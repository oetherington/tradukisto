import {
	ANON_COLUMN_NAME,
	ArrayWrapper,
	type DataType,
	type Declaration,
	type FieldDetails,
	type ResolvedType,
} from "./Declaration";
import { Generator } from "./Generator";
import { ParamMap } from "./ParamMap";

export class TsGenerator extends Generator {
	private static readonly header =
		"/* Generated by tradukisto - do not edit manually */";

	private static readonly dataTypes: Record<string, string> = {
		bigint: "BigInt",
		bigserial: "BigInt",
		boolean: "boolean",
		bytea: "ArrayBuffer",
		"character varying": "string",
		cidr: "string",
		date: "Date",
		varchar: "string",
		"double precision": "number",
		float: "number",
		inet: "string",
		integer: "number",
		interval: "number",
		json: "Json",
		jsonb: "Json",
		money: "number",
		real: "number",
		smallint: "number",
		smallserial: "number",
		serial: "number",
		text: "string",
		time: "Date",
		"time without time zone": "Date",
		"time with time zone": "Date",
		"timestamp without time zone": "Date",
		"timestamp with time zone": "Date",
		tsquery: "string[]",
		tsvector: "string[]",
		unknown: "unknown",
		uuid: "string",
		xml: "string",
	};

	private declarations: Record<string, Declaration> = {};
	private hasJson = false;

	addDeclaration(name: string, decl: Declaration) {
		if (this.declarations[name]) {
			throw new Error(`Duplicate declaration: ${name}`);
		}
		this.declarations[name] = decl;
	}

	private generateSimpleType(dataType: string): string {
		let suffix = "";
		if (dataType.endsWith("[]")) {
			dataType = dataType.slice(0, dataType.length - 2);
			suffix = "[]";
		}
		if (dataType.startsWith("json")) {
			this.hasJson = true;
		}
		return (TsGenerator.dataTypes[dataType] ?? "unknown") + suffix;
	}

	private generateArrayWrapperType(
		dataType: ArrayWrapper,
		indent: number,
		nullablesAreOptional: boolean,
	): string {
		const value = this.generateBaseType(
			dataType.value,
			indent,
			nullablesAreOptional,
		);
		return value + "[]";
	}

	private generateBaseType(
		dataType: DataType,
		indent: number,
		nullablesAreOptional: boolean,
	) {
		if (typeof dataType === "string") {
			return this.generateSimpleType(dataType);
		}
		if (dataType instanceof ArrayWrapper) {
			return this.generateArrayWrapperType(
				dataType,
				indent,
				nullablesAreOptional,
			);
		}
		return this.generateFieldDetailsRecord(
			dataType,
			indent + 2,
			nullablesAreOptional,
		);
	}

	private fieldDetailsToTSType(
		{ dataType, isNullable }: FieldDetails,
		indent: number,
		nullablesAreOptional: boolean,
	) {
		const base = this.generateBaseType(dataType, indent, nullablesAreOptional);
		return isNullable ? base + " | null" : base;
	}

	private fieldDetailsToTS(
		details: FieldDetails,
		indent: number,
		nullablesAreOptional: boolean,
	) {
		if (details.name === ANON_COLUMN_NAME) {
			throw new Error("You must name all anonymous columns");
		}
		const optional = nullablesAreOptional && details.isNullable ? "?" : "";
		const ty = this.fieldDetailsToTSType(details, indent, nullablesAreOptional);
		return `${details.name}${optional}: ${ty},`;
	}

	private generateFieldDetailsRecord(
		value: ResolvedType,
		indent: number,
		nullablesAreOptional: boolean,
	) {
		const lines = [`{`];
		const spaces = " ".repeat(indent + 2);
		for (const details of Object.values(value)) {
			const ty = this.fieldDetailsToTS(details, indent, nullablesAreOptional);
			lines.push(spaces + ty);
		}
		lines.push(" ".repeat(indent) + "}");
		return lines.join("\n");
	}

	generateType(name: string, value: ResolvedType, nullablesAreOptional: boolean) {
		const ty = this.generateFieldDetailsRecord(value, 0, nullablesAreOptional);
		return `export interface ${name} ${ty}`;
	}

	private generateSqlString(
		repoName: string | undefined,
		queryName: string,
		sql: string,
	) {
		const sqlStringName = this.queryNameToSqlName(queryName);
		const comment = `-- ${repoName ? `${repoName}.` : ""}${queryName}\n`;
		const escapedSql = sql.replaceAll("`", "\\`");
		return `export const ${sqlStringName} = \`${comment}${escapedSql}\`;`;
	}

	private generateImports(repoName?: string): string[] {
		const imports = [];
		if (this.hasJson) {
			imports.push("Json");
		}
		if (repoName) {
			imports.push("PostgresClient");
		}
		return imports.length
			? [`import type { ${imports.join(", ")} } from "tradukisto";`]
			: [];
	}

	private queryNameToSqlName(queryName: string) {
		return queryName + "Sql";
	}

	private typeNameToParamsName(queryName: string) {
		return queryName + "Params";
	}

	private generateParams(typeName: string, paramMap: ParamMap): [string, string] {
		if (!paramMap.count()) {
			return ["", ""];
		}
		const namedArgs = `params: ${this.typeNameToParamsName(typeName)}`;
		const paramArray = paramMap.getParamArray();
		const positionalArgs = paramArray
			.map((item) => {
				if (item.endsWith("_")) {
					item = item.slice(0, item.length - 1);
				}
				return `      params.${item} === undefined ? null : params.${item},`;
			})
			.join("\n");
		return [namedArgs, `, [\n${positionalArgs}\n    ]`];
	}

	private generateRepoMethod(decl: Declaration) {
		const { queryName, typeName, paramMap } = decl.getParsedQuery();
		const sqlName = this.queryNameToSqlName(queryName);
		const [namedArgs, positionalArgs] = this.generateParams(typeName, paramMap);
		const allArgs = sqlName + positionalArgs;
		const isSingle = decl.isSingleRow();
		const resultType = isSingle ? `${typeName} | null` : `${typeName}[]`;
		const result: string[] = [
			`\n  async ${queryName}(${namedArgs}): Promise<${resultType}> {`,
			`    const res = await this.client.fetchRows(${allArgs});`,
			`    return ${isSingle ? "res?.[0] ?? null" : "res"};`,
			"  }",
		];
		return result.join("\n");
	}

	private generateRepo(name: string): string {
		const result: string[] = [
			`export class ${name}Repo {`,
			"  protected client: PostgresClient;\n",
			"  constructor(client: PostgresClient) {",
			"    this.client = client;",
			"  }",
		];
		for (const declName in this.declarations) {
			result.push(this.generateRepoMethod(this.declarations[declName]));
		}
		result.push("}");
		return result.join("\n");
	}

	toString(repoName?: string): string {
		const result: string[] = [];
		for (const declName in this.declarations) {
			const decl = this.declarations[declName];
			const { queryName, typeName, query } = decl.getParsedQuery();
			const paramTypeName = this.typeNameToParamsName(typeName);
			const resultType = decl.resolveResultType();
			const parameterTypes = decl.resolveParameterTypes();
			if (Object.keys(resultType).length) {
				const ty = this.generateType(typeName, resultType, false);
				result.push(ty);
			}
			if (Object.keys(parameterTypes).length) {
				const ty = this.generateType(paramTypeName, parameterTypes, true);
				result.push(ty);
			}
			result.push(this.generateSqlString(repoName, queryName, query));
		}
		if (repoName) {
			result.push(this.generateRepo(repoName));
		}
		return [
			TsGenerator.header,
			...this.generateImports(repoName),
			...result,
		].join("\n\n");
	}
}
